<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テーブル定義変換ツール</title>
    <link rel="stylesheet" href="css/pico.min.css">
    <style>
        body {
            padding: 2rem;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        textarea {
            height: 300px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <header class="container">
        <h1>テーブル定義変換ツール</h1>
    </header>

    <main class="container">
        <article>
            <section>
                <h2>1. 入力</h2>
                <nav role="tab-control" class="tabs">
                  <ul>
                    <li><a href="#" data-tab="file-input" class="tab-link active">ファイル入力</a></li>
                    <li><a href="#" data-tab="text-input" class="tab-link">テキストエリア入力</a></li>
                  </ul>
                </nav>
                <div id="file-input" class="tab-content active">
                    <input type="file" id="fileInput">
                    <small>TSVまたはCSVファイルを選択してください。</small>
                </div>
                <div id="text-input" class="tab-content">
                    <textarea id="textInput" placeholder="ここにTSVまたはCSVデータを貼り付けます"></textarea>
                </div>
            </section>

            <section>
                <h2>2. 変換オプション</h2>
                <fieldset>
                    <legend>変換先フォーマット</legend>
                    <label><input type="checkbox" id="ddl" name="format" value="ddl" checked> DDL (PostgreSQL)</label>
                    <label><input type="checkbox" id="typescript" name="format" value="typescript" checked> TypeScript type</label>
                    <label><input type="checkbox" id="zod-schema" name="format" value="zod-schema" checked> Zod Schema</label>
                    <label><input type="checkbox" id="zod-type" name="format" value="zod-type" checked> TypeScript type from Zod</label>
                    <label><input type="checkbox" id="java-model" name="format" value="java-model" checked> Java (EBean) model</label>
                    <label><input type="checkbox" id="java-repo" name="format" value="java-repo" checked> Java repository</label>
                    <label><input type="checkbox" id="java-service" name="format" value="java-service" checked> Java service</label>
                </fieldset>
            </section>

            <section>
                <h2>3. 実行</h2>
                <button id="convertBtn">変換実行</button>
            </section>

            <section>
                <h2>4. 結果</h2>
                <nav role="tab-control" class="tabs">
                    <ul id="result-tabs">
                        <!-- 結果タブがここに追加されます -->
                    </ul>
                </nav>
                <div id="result-contents">
                    <!-- 結果コンテンツがここに追加されます -->
                </div>
                <button id="downloadAllBtn" style="display: none;">すべてダウンロード (ZIP)</button>
            </section>
        </article>
    </main>

    <!-- <script src="https://cdn.jsdelivr.net/npm/zod@3/lib/index.umd.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="js/papaparse.min.js"></script>
    <script src="js/jszip.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            const textInput = document.getElementById('textInput');
            const convertBtn = document.getElementById('convertBtn');
            const resultTabs = document.getElementById('result-tabs');
            const resultContents = document.getElementById('result-contents');
            const downloadAllBtn = document.getElementById('downloadAllBtn');

            // --- Tab UI ---
            document.querySelectorAll('.tab-link').forEach(tab => {
                tab.addEventListener('click', e => {
                    e.preventDefault();
                    const targetId = e.target.dataset.tab;
                    
                    // Handle input tabs
                    if (e.target.closest('.tabs').nextElementSibling.id.includes('input')) {
                        document.querySelectorAll('.tab-link').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        document.querySelectorAll('.tab-content').forEach(content => {
                            if (content.id === targetId) {
                                content.classList.add('active');
                            } else {
                                content.classList.remove('active');
                            }
                        });
                    }
                    // Handle result tabs
                    else {
                         document.querySelectorAll('#result-tabs .tab-link').forEach(t => t.classList.remove('active'));
                         e.target.classList.add('active');
                         document.querySelectorAll('#result-contents .tab-content').forEach(content => {
                            if (content.id === `result-${targetId}`) {
                                content.classList.add('active');
                            } else {
                                content.classList.remove('active');
                            }
                        });
                    }
                });
            });

            // --- Main Logic ---
            convertBtn.addEventListener('click', () => {
                const activeInputTab = document.querySelector('.tab-link.active').dataset.tab;
                if (activeInputTab === 'file-input' && fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        parseAndConvert(e.target.result);
                    };
                    reader.readAsText(file);
                } else if (activeInputTab === 'text-input' && textInput.value.trim() !== '') {
                    parseAndConvert(textInput.value);
                } else {
                    alert('入力データがありません。');
                }
            });

            function parseAndConvert(tsvData) {
                Papa.parse(tsvData, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: '\t',
                    complete: (results) => {
                        if (results.errors.length > 0) {
                            console.error("CSV Parse Errors:", results.errors);
                            alert('CSV/TSVのパースに失敗しました。フォーマットを確認してください。');
                            return;
                        }
                        const intermediateData = transformToIntermediate(results.data);
                        generateOutputs(intermediateData);
                    }
                });
            }

            function transformToIntermediate(data) {
                const tables = {};
                data.forEach(row => {
                    const tableName = row.TableName;
                    if (!tableName) return;

                    if (!tables[tableName]) {
                        tables[tableName] = {
                            tableNo: row.TableNo,
                            tableNameJP: row.TableName_JP,
                            tableName: row.TableName,
                            description: row.Description,
                            columns: [],
                            indexes: {}
                        };
                    }

                    tables[tableName].columns.push({
                        colNo: row.ColNo,
                        colNameJP: row.ColName_JP,
                        colName: row.ColName,
                        pkfk: row['PK/FK'],
                        type: row.Type,
                        length: row.Length,
                        constraint: row.Constraint,
                        default: row.Default,
                        description: row.Description // Description is often on the first row, let's assume it's the same for all columns for now
                    });
                    
                    // Collect indexes
                    for (let i = 1; i <= 5; i++) {
                        const idxKey = `Idx${i}`;
                        if (row[idxKey]) {
                            if (!tables[tableName].indexes[idxKey]) {
                                tables[tableName].indexes[idxKey] = [];
                            }
                            tables[tableName].indexes[idxKey].push({
                                order: parseInt(row[idxKey], 10),
                                colName: row.ColName
                            });
                        }
                    }
                });
                
                // Sort index columns by order
                Object.values(tables).forEach(table => {
                    Object.keys(table.indexes).forEach(idxKey => {
                        table.indexes[idxKey].sort((a, b) => a.order - b.order);
                    });
                });

                return Object.values(tables);
            }

            function generateOutputs(tables) {
                resultTabs.innerHTML = '';
                resultContents.innerHTML = '';
                downloadAllBtn.style.display = 'block';

                const formats = Array.from(document.querySelectorAll('input[name="format"]:checked')).map(cb => cb.value);
                let firstTab = true;

                formats.forEach(format => {
                    const tab = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = '#';
                    link.dataset.tab = format;
                    link.className = 'tab-link' + (firstTab ? ' active' : '');
                    link.textContent = format.toUpperCase();
                    tab.appendChild(link);
                    resultTabs.appendChild(tab);

                    const content = document.createElement('div');
                    content.id = `result-${format}`;
                    content.className = 'tab-content' + (firstTab ? ' active' : '');
                    
                    const textArea = document.createElement('textarea');
                    textArea.readOnly = true;
                    
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = `${format.toUpperCase()} をダウンロード`;
                    downloadBtn.addEventListener('click', () => downloadFile(textArea.value, `output.${format}`));

                    // Generate content using stub functions
                    let output = '';
                    switch (format) {
                        case 'ddl': output = generateDDL(tables); break;
                        case 'typescript': output = generateTypeScript(tables); break;
                        case 'zod-schema': output = generateZodSchema(tables); break;
                        case 'zod-type': output = generateZodType(tables); break;
                        case 'java-model': output = generateJavaModel(tables); break;
                        case 'java-repo': output = generateJavaRepo(tables); break;
                        case 'java-service': output = generateJavaService(tables); break;
                    }
                    textArea.value = output;

                    content.appendChild(downloadBtn);
                    content.appendChild(textArea);
                    resultContents.appendChild(content);

                    firstTab = false;
                });
                
                // Re-add tab click listeners for result tabs
                document.querySelectorAll('#result-tabs .tab-link').forEach(tab => {
                    tab.addEventListener('click', e => {
                        e.preventDefault();
                        const targetId = e.target.dataset.tab;
                        document.querySelectorAll('#result-tabs .tab-link').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        document.querySelectorAll('#result-contents .tab-content').forEach(c => {
                            c.classList.toggle('active', c.id === `result-${targetId}`);
                        });
                    });
                });
            }
            
            downloadAllBtn.addEventListener('click', () => {
                const zip = new JSZip();
                const formats = Array.from(document.querySelectorAll('input[name="format"]:checked')).map(cb => cb.value);
                
                const activeInputTab = document.querySelector('.tab-link.active').dataset.tab;
                let tsvData = '';
                 if (activeInputTab === 'file-input' && fileInput.files.length > 0) {
                    // This is async, so we need to handle it inside the reader's onload
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        proceedWithZipping(e.target.result);
                    };
                    reader.readAsText(fileInput.files[0]);
                    return; // Exit here, proceedWithZipping will be called by reader
                } else if (activeInputTab === 'text-input' && textInput.value.trim() !== '') {
                    tsvData = textInput.value;
                } else {
                    alert('入力データがありません。');
                    return;
                }
                proceedWithZipping(tsvData);

                function proceedWithZipping(data) {
                    Papa.parse(data, {
                        header: true,
                        skipEmptyLines: true,
                        delimiter: '\t',
                        complete: (results) => {
                            if (results.errors.length > 0) {
                                alert('CSV/TSVのパースに失敗しました。');
                                return;
                            }
                            const tables = transformToIntermediate(results.data);
                            
                            formats.forEach(format => {
                                let output = '';
                                switch (format) {
                                    case 'ddl':
                                        output = generateDDL(tables);
                                        zip.file('schema.sql', output);
                                        break;
                                    case 'typescript':
                                        output = generateTypeScript(tables);
                                        zip.file('entities.ts', output);
                                        break;
                                    case 'zod-schema':
                                        output = generateZodSchema(tables);
                                        zip.file('schemas.ts', output);
                                        break;
                                    case 'zod-type':
                                        output = generateZodType(tables);
                                        zip.file('zod-types.ts', output);
                                        break;
                                    case 'java-model':
                                    case 'java-repo':
                                    case 'java-service':
                                        output = format === 'java-model' ? generateJavaModel(tables) :
                                                 format === 'java-repo'  ? generateJavaRepo(tables)  :
                                                                            generateJavaService(tables);
                                        
                                        const files = output.split('// --- FileName: ');
                                        files.forEach(fileContent => {
                                            if (fileContent.trim() === '') return;
                                            const firstLineEnd = fileContent.indexOf(' ---\n');
                                            const fileName = fileContent.substring(0, firstLineEnd).trim();
                                            const content = fileContent.substring(firstLineEnd + 5);
                                            
                                            let path = '';
                                            if (format === 'java-model') path = 'models/';
                                            else if (format === 'java-repo') path = 'repository/';
                                            else if (format === 'java-service') path = 'services/';
                                            
                                            zip.file(path + fileName, content.trim());
                                        });
                                        break;
                                }
                            });

                            zip.generateAsync({ type: "blob" })
                                .then(function(content) {
                                    downloadFile(content, 'table-definitions.zip');
                                });
                        }
                    });
                }
            });
            
            function downloadFile(content, fileName) {
                const blob = (content instanceof Blob) ? content : new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- Conversion Stubs ---
            function generateDDL(tables) {
                let ddl = '';
                tables.forEach(table => {
                    const tableName = table.tableName;
                    const pkColumns = table.columns.filter(c => c.pkfk === 'PK').map(c => c.colName);
                    const akColumns = table.columns.filter(c => c.pkfk === 'AK').map(c => c.colName);

                    // DROP TABLE
                    ddl += `DROP TABLE IF EXISTS ${tableName};\n\n`;

                    // CREATE TABLE
                    ddl += `CREATE TABLE ${tableName} (\n`;
                    const columnDefs = table.columns.map(col => {
                        let def = `    ${col.colName}`;
                        // Type and Length
                        if (col.type === 'varchar' && col.Length) {
                            def += ` VARCHAR(${col.Length})`;
                        } else if (col.type === 'char' && col.Length) {
                            def += ` CHAR(${col.Length})`;
                        } else {
                            def += ` ${col.type.toUpperCase()}`;
                        }
                        // Constraints
                        if (col.constraint) {
                            if (col.constraint.includes('NN')) {
                                def += ' NOT NULL';
                            }
                            if (col.constraint.includes('U')) {
                                def += ' UNIQUE';
                            }
                        }
                        // Default
                        if (col.default) {
                            def += ` DEFAULT ${col.default}`;
                        }
                        return def;
                    });
                    
                    ddl += columnDefs.join(',\n');
                    
                    // Primary Key
                    if (pkColumns.length > 0) {
                        ddl += `,\n    PRIMARY KEY (${pkColumns.join(', ')})`;
                    }
                    
                    // Alternate Key (Unique Constraint)
                    if (akColumns.length > 0) {
                        ddl += `,\n    CONSTRAINT ${tableName}_ak UNIQUE (${akColumns.join(', ')})`;
                    }

                    ddl += '\n);\n\n';

                    // Comments
                    ddl += `COMMENT ON TABLE ${tableName} IS '${table.tableNameJP}';\n`;
                    table.columns.forEach(col => {
                        ddl += `COMMENT ON COLUMN ${tableName}.${col.colName} IS '${col.colNameJP}';\n`;
                    });
                    ddl += '\n';

                    // Indexes
                    Object.keys(table.indexes).forEach(idxKey => {
                        const index = table.indexes[idxKey];
                        const indexName = `${tableName}_${idxKey.toLowerCase()}`;
                        const indexColumns = index.map(i => i.colName).join(', ');
                        ddl += `CREATE INDEX ${indexName} ON ${tableName} (${indexColumns});\n`;
                    });
                    ddl += '\n-- --------------------------------------------------\n\n';
                });
                return ddl;
            }
            function generateTypeScript(tables) {
                const toPascalCase = (s) => s.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
                const toCamelCase = (s) => {
                    const pascal = toPascalCase(s);
                    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
                };

                const mapPostgresToTsType = (pgType) => {
                    pgType = pgType.toLowerCase();
                    if (['bigint', 'bigserial', 'integer', 'smallint', 'numeric', 'decimal'].includes(pgType)) {
                        return 'number';
                    }
                    if (['varchar', 'char', 'text', 'bytea', 'bit'].includes(pgType)) {
                        return 'string';
                    }
                    if (['boolean'].includes(pgType)) {
                        return 'boolean';
                    }
                    if (['date', 'time', 'timestamp'].includes(pgType)) {
                        return 'string'; // Or Date, but string is often safer for serialization
                    }
                    return 'any';
                };

                let tsString = '';
                tables.forEach(table => {
                    const typeName = toPascalCase(table.tableName);
                    tsString += `/**\n * @type ${typeName} ${table.tableNameJP}\n */\n`;
                    tsString += `export type ${typeName} = {\n`;

                    table.columns.forEach(col => {
                        const propName = toCamelCase(col.colName);
                        const tsType = mapPostgresToTsType(col.type);
                        tsString += `  /** ${col.colNameJP} */\n`;
                        // All properties are optional for flexibility
                        tsString += `  ${propName}?: ${tsType};\n`;
                    });

                    tsString += '};\n\n';
                });

                return tsString;
            }
            function generateZodSchema(tables) {
                const toPascalCase = (s) => s.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
                const toCamelCase = (s) => {
                    const pascal = toPascalCase(s);
                    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
                };

                const mapPostgresToZod = (col) => {
                    const pgType = col.type.toLowerCase();
                    let zodType;

                    if (['bigint', 'bigserial', 'integer', 'smallint', 'numeric', 'decimal'].includes(pgType)) {
                        zodType = 'z.number()';
                    } else if (['varchar', 'char', 'text', 'bytea', 'bit'].includes(pgType)) {
                        zodType = 'z.string()';
                        const isNotNull = col.constraint && col.constraint.includes('NN');
                        const excludeMinLength = ['description', 'note', 'remarks'].some(keyword => col.colName.toLowerCase().includes(keyword));

                        if (isNotNull && !excludeMinLength) {
                            zodType += '.min(1)';
                        }
                        if (col.length) {
                            zodType += `.max(${col.length})`;
                        }
                    } else if (['boolean'].includes(pgType)) {
                        zodType = 'z.boolean()';
                    } else if (['date', 'time', 'timestamp'].includes(pgType)) {
                        zodType = 'z.iso.datetime()'; // Or z.date()
                    } else {
                        zodType = 'z.any()';
                    }
                    
                    if (col.constraint && !col.constraint.includes('NN')) {
                        zodType += '.optional()';
                    }
                     if (col.default) {
                        // This is a simplification, default values in Zod need to match the type
                        // For now, we just add a comment.
                        // zodType += `.default(${col.default})`;
                    }
                    if (col.colNameJP) {
                         zodType += `.describe('${col.colNameJP}')`;
                    }


                    return zodType;
                };

                let zodString = `import { z } from 'zod';\n\n`;
                tables.forEach(table => {
                    const schemaName = `${toPascalCase(table.tableName)}Schema`;
                    zodString += `/**\n * ${table.tableNameJP}\n */\n`;
                    zodString += `export const ${schemaName} = z.object({\n`;

                    table.columns.forEach(col => {
                        const propName = toCamelCase(col.colName);
                        const zodType = mapPostgresToZod(col);
                        zodString += `  ${propName}: ${zodType},\n`;
                    });

                    zodString += '});\n\n';
                });

                return zodString;
            }

            function generateZodType(tables) {
                const toPascalCase = (s) => s.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
                let typeString = `import { z } from 'zod';\n`;
                typeString += `import { `;
                
                const schemaNames = tables.map(table => `${toPascalCase(table.tableName)}Schema`);
                typeString += schemaNames.join(', ');
                
                typeString += ` } from './schemas'; // Assuming schemas are in a file named schemas.ts\n\n`;

                tables.forEach(table => {
                    const typeName = toPascalCase(table.tableName);
                    const schemaName = `${typeName}Schema`;
                    typeString += `/**\n * @type ${typeName} ${table.tableNameJP}\n */\n`;
                    typeString += `export type ${typeName} = z.infer<typeof ${schemaName}>;\n\n`;
                });

                return typeString;
            }
            function generateJavaModel(tables) {
                const toPascalCase = (s) => s.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
                const toCamelCase = (s) => {
                    const pascal = toPascalCase(s);
                    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
                };

                const mapPostgresToJavaType = (pgType) => {
                    pgType = pgType.toLowerCase();
                    if (['bigserial', 'bigint'].includes(pgType)) return 'Long';
                    if (['integer', 'smallint'].includes(pgType)) return 'Integer';
                    if (['varchar', 'char', 'text', 'bit'].includes(pgType)) return 'String';
                    if (['boolean'].includes(pgType)) return 'Boolean';
                    if (['timestamp', 'date', 'time'].includes(pgType)) return 'java.time.Instant';
                    if (['bytea'].includes(pgType)) return 'byte[]';
                    return 'Object';
                };
                
                const baseModelCols = new Set(['id', 'is_deleted', 'created_at', 'created_by', 'updated_at', 'updated_by']);

                const baseModelContent = `
// --- FileName: BaseModel.java ---
package models;

import io.ebean.Model;
import io.ebean.annotation.WhenCreated;
import io.ebean.annotation.WhenModified;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;

/**
 * 全テーブル共通の項目を定義する基底モデル
 */
@MappedSuperclass
@Getter
@Setter
public class BaseModel extends Model {
    @Id
    public Long id;

    /**
     * 論理削除フラグ
     */
    public Boolean isDeleted = false;

    /**
     * 作成日時
     */
    @WhenCreated
    public Instant createdAt;
    
    /** 
     * 作成者ID
     */
    public String createdBy;

    /**
     * 更新日時
     */
    @WhenModified
    public Instant updatedAt;
    
    /**
     * 更新者ID
     */
    public String updatedBy;
}
`;
                let javaString = baseModelContent.trim() + '\n\n';

                tables.forEach(table => {
                    const className = toPascalCase(table.tableName);
                    const imports = new Set([
                        'import io.ebean.Finder;',
                        'import jakarta.persistence.Entity;',
                        'import jakarta.persistence.Table;',
                        'import lombok.Getter;',
                        'import lombok.Setter;'
                    ]);

                    let fieldsContent = '';
                    table.columns.forEach(col => {
                        if (baseModelCols.has(col.colName)) {
                            return; // Skip columns defined in BaseModel
                        }
                        const fieldName = toCamelCase(col.colName);
                        const javaType = mapPostgresToJavaType(col.type);
                        
                        let annotations = [];
                        const isNotNull = col.constraint && col.constraint.includes('NN');
                        
                        if (isNotNull) {
                            annotations.push('@NotNull');
                            imports.add('import javax.validation.constraints.NotNull;');
                        }

                        const sizeAttributes = [];
                        const excludeMinLength = ['description', 'note', 'remarks'].some(keyword => col.colName.toLowerCase().includes(keyword));
                        if (javaType === 'String' && isNotNull && !excludeMinLength) {
                            sizeAttributes.push('min = 1');
                        }
                        if (col.length) {
                            sizeAttributes.push(`max = ${col.length}`);
                        }
                        if (sizeAttributes.length > 0) {
                            annotations.push(`@Size(${sizeAttributes.join(', ')})`);
                            imports.add('import javax.validation.constraints.Size;');
                        }

                        fieldsContent += `    /**\n     * ${col.colNameJP}\n     */\n`;
                        if (annotations.length > 0) {
                            fieldsContent += `    ${annotations.join('\n    ')}\n`;
                        }
                        fieldsContent += `    public ${javaType} ${fieldName};\n\n`;
                    });

                    let classContent = `// --- FileName: ${className}.java ---\n`;
                    classContent += `package models;\n\n`;
                    classContent += `${[...imports].sort().join('\n')}\n\n`;
                    classContent += `/**\n * ${table.tableNameJP}\n */\n`;
                    classContent += `@Entity\n@Getter\n@Setter\n`;
                    classContent += `@Table(name = "${table.tableName}")\n`;
                    classContent += `public class ${className} extends BaseModel {\n\n`;
                    classContent += fieldsContent;
                    classContent += `    public static Finder<Long, ${className}> find = new Finder<>(${className}.class);\n`;
                    classContent += `}\n`;
                    javaString += classContent + '\n';
                });

                return javaString;
            }
            function generateJavaRepo(tables) {
                const toPascalCase = (s) => s.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
                const toCamelCase = (s) => {
                    const pascal = toPascalCase(s);
                    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
                };
                 const mapPostgresToJavaType = (pgType) => {
                    pgType = pgType.toLowerCase();
                    if (['bigserial', 'bigint'].includes(pgType)) return 'Long';
                    if (['integer', 'smallint'].includes(pgType)) return 'Integer';
                    if (['varchar', 'char', 'text', 'bit'].includes(pgType)) return 'String';
                    if (['boolean'].includes(pgType)) return 'Boolean';
                    if (['timestamp', 'date', 'time'].includes(pgType)) return 'java.time.Instant';
                    if (['bytea'].includes(pgType)) return 'byte[]';
                    return 'Object';
                };
                const baseModelCols = new Set(['id', 'is_deleted', 'created_at', 'created_by', 'updated_at', 'updated_by']);

                const exceptionContent = `
// --- FileName: OptimisticLockingFailureException.java ---
package repository;

/**
 * 楽観的ロック失敗時にスローされる例外
 */
public class OptimisticLockingFailureException extends RuntimeException {
    public OptimisticLockingFailureException(String message) {
        super(message);
    }
}
`;
                let javaString = exceptionContent.trim() + '\n\n';


                tables.forEach(table => {
                    const modelName = toPascalCase(table.tableName);
                    const repoName = `${modelName}Repository`;
                    const modelVar = toCamelCase(modelName);
                    const akColumns = table.columns.filter(c => c.pkfk === 'AK');

                    let classContent = `// --- FileName: ${repoName}.java ---\n`;
                    classContent += `package repository;\n\n`;
                    classContent += `import io.ebean.DB;\n`;
                    classContent += `import models.${modelName};\n`;
                    classContent += `import jakarta.persistence.EntityNotFoundException;\n`;
                    classContent += `import javax.inject.Inject;\n`;
                    classContent += `import java.time.Instant;\n`;
                    classContent += `import java.util.List;\n`;
                    classContent += `import java.util.Optional;\n`;
                    classContent += `import java.util.concurrent.CompletionStage;\n\n`;
                    classContent += `import static java.util.concurrent.CompletableFuture.supplyAsync;\n\n`;

                    classContent += `/**\n * ${table.tableNameJP} のリポジトリ\n */\n`;
                    classContent += `public class ${repoName} {\n`;
                    classContent += `    private final DatabaseExecutionContext executionContext;\n\n`;
                    classContent += `    @Inject\n`;
                    classContent += `    public ${repoName}(DatabaseExecutionContext executionContext) {\n`;
                    classContent += `        this.executionContext = executionContext;\n`;
                    classContent += `    }\n\n`;

                    // findById
                    classContent += `    /**\n     * IDで ${table.tableNameJP} を検索します（論理削除済みは除く）。\n     * @param id 主キー\n     * @return 検索結果\n     */\n`;
                    classContent += `    public CompletionStage<Optional<${modelName}>> findById(Long id) {\n`;
                    classContent += `        return supplyAsync(() ->\n`;
                    classContent += `            DB.find(${modelName}.class)\n`;
                    classContent += `                .where()\n`;
                    classContent += `                .eq("id", id)\n`;
                    classContent += `                .eq("isDeleted", false)\n`;
                    classContent += `                .findOneOrEmpty()\n`;
                    classContent += `        , executionContext);\n`;
                    classContent += `    }\n\n`;
                    
                    // findByAK
                    akColumns.forEach(col => {
                        const colCamel = toCamelCase(col.colName);
                        const colPascal = toPascalCase(col.colName);
                        const colType = mapPostgresToJavaType(col.type);
                        classContent += `    /**\n     * ${col.colNameJP} で ${table.tableNameJP} を検索します（論理削除済みは除く）。\n     * @param ${colCamel} ${col.colNameJP}\n     * @return 検索結果\n     */\n`;
                        classContent += `    public CompletionStage<Optional<${modelName}>> findBy${colPascal}(${colType} ${colCamel}) {\n`;
                        classContent += `        return supplyAsync(() ->\n`;
                        classContent += `            DB.find(${modelName}.class)\n`;
                        classContent += `                .where()\n`;
                        classContent += `                .eq("${colCamel}", ${colCamel})\n`;
                        classContent += `                .eq("isDeleted", false)\n`;
                        classContent += `                .findOneOrEmpty()\n`;
                        classContent += `        , executionContext);\n`;
                        classContent += `    }\n\n`;
                    });

                    // findAll
                    classContent += `    /**\n     * 全ての ${table.tableNameJP} を取得します（論-理削除済みは除く）。\n     * @return 全件リスト\n     */\n`;
                    classContent += `    public CompletionStage<List<${modelName}>> findAll() {\n`;
                    classContent += `        return findAll(0, Integer.MAX_VALUE);\n`;
                    classContent += `    }\n\n`;

                    // findAll
                    classContent += `    /**\n     * 全ての ${table.tableNameJP} を取得します（論-理削除済みは除く）。\n     * @return 全件リスト\n     */\n`;
                    classContent += `    public CompletionStage<List<${modelName}>> findAll(int offset, int limit) {\n`;
                    classContent += `        return supplyAsync(() ->\n`;
                    classContent += `            DB.find(${modelName}.class)\n`;
                    classContent += `                .where()\n`;
                    classContent += `                .eq("isDeleted", false)\n`;
                    classContent += `                .setFirstRow(offset)\n`;
                    classContent += `                .setMaxRows(limit)\n`;
                    classContent += `                .findList()\n`;
                    classContent += `        , executionContext);\n`;
                    classContent += `    }\n\n`;

                    classContent += `    /**\n     * 全ての ${table.tableNameJP} の件数を取得します（論理削除済みは除く）。\n     * @return 件数\n     */\n`;
                    classContent += `    public CompletionStage<Integer> countAll() {\n`;
                    classContent += `        return supplyAsync(() ->\n`;
                    classContent += `            DB.find(${modelName}.class)\n`;
                    classContent += `                .where()\n`;
                    classContent += `                .eq("isDeleted", false)\n`;
                    classContent += `                .findCount()\n`;
                    classContent += `        , executionContext);\n`;
                    classContent += `    }\n\n`;

                    // find (with filter)
                    classContent += `    /**\n     * ${table.tableNameJP} を検索します（論理削除済みは除く）。\n     * @param filter 検索条件\n     * @return 検索結果リスト\n     */\n`;
                    classContent += `    public CompletionStage<List<${modelName}>> find(${modelName} filter) {\n`;
                    classContent += `        return find(filter, 0, Integer.MAX_VALUE);\n`;
                    classContent += `    }\n\n`;

                    // find (with filter)
                    classContent += `    /**\n     * ${table.tableNameJP} を検索します（論理削除済みは除く）。\n     * @param filter 検索条件\n     * @return 検索結果リスト\n     */\n`;
                    classContent += `    public CompletionStage<List<${modelName}>> find(${modelName} filter, int offset, int limit) {\n`;
                    classContent += `        return supplyAsync(() ->\n`;
                    classContent += `            createQueryWithFilter(filter)\n`;
                    classContent += `                .setFirstRow(offset)\n`;
                    classContent += `                .setMaxRows(limit)\n`;
                    classContent += `                .findList()\n`;
                    classContent += `        , executionContext);\n`;
                    classContent += `    }\n\n`;

                    classContent += `    /**\n     * ${table.tableNameJP} の件数を検索条件に基づいて取得します（論理削除済みは除く）。\n     * @param filter 検索条件\n     * @return 件数\n     */\n`;
                    classContent += `    public CompletionStage<Integer> count(${modelName} filter) {\n`;
                    classContent += `        return supplyAsync(() ->\n`;
                    classContent += `            createQueryWithFilter(filter).findCount()\n`;
                    classContent += `        , executionContext);\n`;
                    classContent += `    }\n\n`;

                    classContent += `    /**\n     * 検索条件に基づいてクエリを構築します。\n     * @param filter 検索条件\n     * @return 構築されたクエリ\n     */\n`;
                    classContent += `    private io.ebean.ExpressionList<${modelName}> createQueryWithFilter(${modelName} filter) {\n`;
                    classContent += `        io.ebean.ExpressionList<${modelName}> query = DB.find(${modelName}.class).where().eq("isDeleted", false);\n\n`;
                    table.columns.forEach(col => {
                        if (!baseModelCols.has(col.colName)) {
                            const colCamel = toCamelCase(col.colName);
                            const colPascal = toPascalCase(col.colName);
                            const javaType = mapPostgresToJavaType(col.type);
                            classContent += `        if (filter.get${colPascal}() != null) {\n`;
                            if (javaType === 'String') {
                                classContent += `            query.contains("${colCamel}", filter.get${colPascal}());\n`;
                            } else {
                                classContent += `            query.eq("${colCamel}", filter.get${colPascal}());\n`;
                            }
                            classContent += `        }\n`;
                        }
                    });
                    classContent += `\n        return query;\n`;
                    classContent += `    }\n\n`;

                    // insert
                    classContent += `    /**\n     * ${table.tableNameJP} を新規登録します。\n     * @param ${modelVar} 登録データ\n     * @return 登録後のデータ\n     */\n`;
                    classContent += `    public CompletionStage<${modelName}> insert(${modelName} ${modelVar}) {\n`;
                    classContent += `        return supplyAsync(() -> {\n`;
                    classContent += `            DB.insert(${modelVar});\n`;
                    classContent += `            return ${modelVar};\n`;
                    classContent += `        }, executionContext);\n`;
                    classContent += `    }\n\n`;
                    
                    // batchInsert
                    classContent += `    /**\n     * ${table.tableNameJP} を一括で新規登録します。\n     * @param ${modelVar}s 登録データリスト\n     * @return 登録件数\n     */\n`;
                    classContent += `    public CompletionStage<Integer> batchInsert(List<${modelName}> ${modelVar}s) {\n`;
                    classContent += `        return supplyAsync(() -> {\n`;
                    classContent += `            DB.saveAll(${modelVar}s);\n`;
                    classContent += `            return ${modelVar}s.size();\n`;
                    classContent += `        }, executionContext);\n`;
                    classContent += `    }\n\n`;

                    // update
                    classContent += `    /**\n     * ${table.tableNameJP} を更新します。\n     * @param id 主キー\n     * @param newData 更新データ\n     * @param updatedAt タイムスタンプ\n     * @return 更新後のデータ\n     */\n`;
                    classContent += `    public CompletionStage<${modelName}> update(Long id, ${modelName} newData, Instant updatedAt) {\n`;
                    classContent += `        return supplyAsync(() -> {\n`;
                    classContent += `            newData.setId(id);\n`;
                    classContent += `            int updatedRows = DB.update(${modelName}.class)\n`;
                    classContent += `                .set("updatedAt", Instant.now())\n`;
                    table.columns.forEach(col => {
                        if (!baseModelCols.has(col.colName)) {
                            const colCamel = toCamelCase(col.colName);
                            const colPascal = toPascalCase(col.colName);
                            classContent += `                .set("${colCamel}", newData.get${colPascal}())\n`;
                        }
                    });
                    classContent += `                .where().eq("id", id).eq("updatedAt", updatedAt)\n`;
                    classContent += `                .update();\n\n`;
                    classContent += `            if (updatedRows == 0) {\n`;
                    classContent += `                throw new OptimisticLockingFailureException("${modelName} not found with id: " + id + " and updatedAt: " + updatedAt);\n`;
                    classContent += `            }\n`;
                    classContent += `            return newData;\n`;
                    classContent += `        }, executionContext);\n`;
                    classContent += `    }\n\n`;

                    // delete (logical)
                    classContent += `    /**\n     * ${table.tableNameJP} を論理削除します。\n     * @param id 主キー\n     * @param updatedAt タイムスタンプ\n     */\n`;
                    classContent += `    public CompletionStage<Void> delete(Long id, Instant updatedAt) {\n`;
                    classContent += `        return supplyAsync(() -> {\n`;
                    classContent += `            int updatedRows = DB.update(${modelName}.class)\n`;
                    classContent += `                .set("isDeleted", true)\n`;
                    classContent += `                .set("updatedAt", Instant.now())\n`;
                    classContent += `                .where().eq("id", id).eq("updatedAt", updatedAt)\n`;
                    classContent += `                .update();\n\n`;
                    classContent += `            if (updatedRows == 0) {\n`;
                    classContent += `                throw new OptimisticLockingFailureException("${modelName} not found with id: " + id + " and updatedAt: " + updatedAt);\n`;
                    classContent += `            }\n`;
                    classContent += `            return null;\n`;
                    classContent += `        }, executionContext);\n`;
                    classContent += `    }\n`;

                    classContent += `}\n`;
                    javaString += classContent + '\n';
                });

                return javaString;
            }
            function generateJavaService(tables) {
                const toPascalCase = (s) => s.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
                const toCamelCase = (s) => {
                    const pascal = toPascalCase(s);
                    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
                };

                const mapPostgresToJavaType = (pgType) => {
                    pgType = pgType.toLowerCase();
                    if (['bigserial', 'bigint'].includes(pgType)) return 'Long';
                    if (['integer', 'smallint'].includes(pgType)) return 'Integer';
                    if (['varchar', 'char', 'text', 'bit'].includes(pgType)) return 'String';
                    if (['boolean'].includes(pgType)) return 'Boolean';
                    if (['timestamp', 'date', 'time'].includes(pgType)) return 'java.time.Instant';
                    if (['bytea'].includes(pgType)) return 'byte[]';
                    return 'Object';
                };

                let javaString = '';
                tables.forEach(table => {
                    const modelName = toPascalCase(table.tableName);
                    const serviceName = `${modelName}Service`;
                    const repoName = `${modelName}Repository`;
                    const repoVar = toCamelCase(repoName);
                    const modelVar = toCamelCase(modelName);

                    let classContent = `// --- FileName: ${serviceName}.java ---\n`;
                    classContent += `package services;\n\n`;
                    classContent += `import com.fasterxml.jackson.databind.node.ObjectNode;\n`;
                    classContent += `import models.${modelName};\n`;
                    classContent += `import play.libs.Json;\n`;
                    classContent += `import repository.${repoName};\n`;
                    classContent += `import javax.inject.Inject;\n`;
                    classContent += `import java.io.BufferedWriter;\n`;
                    classContent += `import java.io.File;\n`;
                    classContent += `import java.io.IOException;\n`;
                    classContent += `import java.io.PrintWriter;\n`;
                    classContent += `import java.nio.file.Files;\n`;
                    classContent += `import java.time.Instant;\n`;
                    classContent += `import java.util.ArrayList;\n`;
                    classContent += `import java.util.List;\n`;
                    classContent += `import java.util.Optional;\n`;
                    classContent += `import java.util.concurrent.CompletionStage;\n`;
                    classContent += `import java.util.function.Function;\n`;
                    classContent += `import java.util.stream.Collectors;\n`;
                    classContent += `import static java.util.concurrent.CompletableFuture.supplyAsync;\n\n`;


                    classContent += `/**\n * ${table.tableNameJP} のサービス\n */\n`;
                    classContent += `public class ${serviceName} {\n`;
                    classContent += `    private final ${repoName} ${repoVar};\n\n`;
                    classContent += `    @Inject\n`;
                    classContent += `    public ${serviceName}(${repoName} ${repoVar}) {\n`;
                    classContent += `        this.${repoVar} = ${repoVar};\n`;
                    classContent += `    }\n\n`;

                    classContent += `    public CompletionStage<ObjectNode> find() {\n`;
                    classContent += `        return find(0, Integer.MAX_VALUE);\n`;
                    classContent += `    }\n\n`;
                    
                    // find (as JSON)
                    classContent += `    /**\n     * ${table.tableNameJP} のリストをJSONで取得します。\n     * @return JSON形式の検索結果\n     */\n`;
                    classContent += `    public CompletionStage<ObjectNode> find(int offset, int limit) {\n`;
                    classContent += `        CompletionStage<Integer> totalFuture = ${repoVar}.countAll();\n`;
                    classContent += `        CompletionStage<List<${modelName}>> dataFuture = ${repoVar}.findAll(offset, limit);\n`;
                    classContent += `        return totalFuture.thenCombine(dataFuture, (total, data) -> {\n`;
                    classContent += `            ObjectNode result = Json.newObject();\n`;
                    classContent += `            result.put("total", total);\n`;
                    classContent += `            result.set("data", Json.toJson(data));\n`;
                    classContent += `            return result;\n`;
                    classContent += `        });\n`;
                    classContent += `    }\n\n`;

                    classContent += `    public CompletionStage<ObjectNode> find(${modelName} filter) {\n`;
                    classContent += `        return find(filter, 0, Integer.MAX_VALUE);\n`;
                    classContent += `    }\n\n`;
                    
                    // find (with filter)
                    classContent += `    /**\n     * ${table.tableNameJP} を検索し、リストをJSONで取得します。\n     * @param filter 検索条件\n     * @return JSON形式の検索結果\n     */\n`;
                    classContent += `    public CompletionStage<ObjectNode> find(${modelName} filter, int offset, int limit) {\n`;
                    classContent += `        CompletionStage<Integer> totalFuture = ${repoVar}.count(filter);\n`;
                    classContent += `        CompletionStage<List<${modelName}>> dataFuture = ${repoVar}.find(filter, offset, limit);\n`;
                    classContent += `        return totalFuture.thenCombine(dataFuture, (total, data) -> {\n`;
                    classContent += `            ObjectNode result = Json.newObject();\n`;
                    classContent += `            result.put("total", total);\n`;
                    classContent += `            result.set("data", Json.toJson(data));\n`;
                    classContent += `            return result;\n`;
                    classContent += `        });\n`;
                    classContent += `    }\n\n`;

                    // findById
                    classContent += `    /**\n     * IDで ${table.tableNameJP} を検索します。\n     * @param id 主キー\n     * @return 検索結果\n     */\n`;
                    classContent += `    public CompletionStage<Optional<${modelName}>> findById(Long id) {\n`;
                    classContent += `        return ${repoVar}.findById(id);\n`;
                    classContent += `    }\n\n`;

                    // create
                    classContent += `    /**\n     * ${table.tableNameJP} を新規登録します。\n     * @param ${modelVar} 登録データ\n     * @return 登録後のデータ\n     */\n`;
                    classContent += `    public CompletionStage<${modelName}> create(${modelName} ${modelVar}) {\n`;
                    classContent += `        return ${repoVar}.insert(${modelVar});\n`;
                    classContent += `    }\n\n`;

                    // update
                    classContent += `    /**\n     * ${table.tableNameJP} を更新します。\n     * @param id 主キー\n     * @param ${modelVar} 更新データ\n     * @return 更新後のデータ\n     */\n`;
                    classContent += `    public CompletionStage<${modelName}> update(Long id, ${modelName} ${modelVar}) {\n`;
                    classContent += `        return ${repoVar}.update(id, ${modelVar}, ${modelVar}.getUpdatedAt());\n`;
                    classContent += `    }\n\n`;

                    // delete
                    classContent += `    /**\n     * ${table.tableNameJP} を論理削除します。\n     * @param id 主キー\n     * @param updatedAt タイムスタンプ\n     */\n`;
                    classContent += `    public CompletionStage<Void> delete(Long id, Instant updatedAt) {\n`;
                    classContent += `        return ${repoVar}.delete(id, updatedAt);\n`;
                    classContent += `    }\n\n`;
                    
                    const nonKeyColumns = table.columns.filter(c => c.pkfk !== 'PK' && c.colName !== 'id');
                    const csvHeader = nonKeyColumns.map(c => `\\"${c.colNameJP}\\"`).join(",");
                    const csvPlaceHolder = nonKeyColumns.map(c => `%s`).join(",");
                    const csvRow = nonKeyColumns.map(c => `\\"String.valueOf(m.get${toPascalCase(c.colName)}())\\"`).join(',');

                    classContent += `    /**\n     * ${table.tableNameJP} のデータをCSVファイルとしてエクスポートします。\n     * @param filter 検索条件\n     * @return 生成されたCSVファイル\n     */\n`;
                    classContent += `    public CompletionStage<File> exportCsv(${modelName} filter) {\n`;
                    classContent += `        return ${repoVar}.find(filter, 0, Integer.MAX_VALUE).thenApply(list -> {\n`;
                    classContent += `            try {\n`;
                    classContent += `                File file = Files.createTempFile("${table.tableName}_", ".csv").toFile();\n`;
                    classContent += `                try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(file.toPath()))) {\n`;
                    classContent += `                    writer.printf("${csvPlaceHolder}","${csvHeader}");\n`;
                    classContent += `                    for (${modelName} m : list) {\n`;
                    classContent += `                        writer.printf("${csvPlaceHolder}","${csvRow}");\n`;
                    classContent += `                    }\n`;
                    classContent += `                }\n`;
                    classContent += `                return file;\n`;
                    classContent += `            } catch (IOException e) {\n`;
                    classContent += `                throw new RuntimeException(e);\n`;
                    classContent += `            }\n`;
                    classContent += `        });\n`;
                    classContent += `    }\n\n`;
                    
                    const nonKeyColumnsForImport = table.columns.filter(c => c.pkfk !== 'PK' && c.colName !== 'id');
                    
                    classContent += `    /**\n     * CSVファイルから ${table.tableNameJP} のデータを取り込みます。\n     * @param csvFile 取り込むCSVファイル\n     * @return 取り込み件数\n     */\n`;
                    classContent += `    public CompletionStage<Integer> importCsv(File csvFile) {\n`;
                    classContent += `        return supplyAsync(() -> {\n`;
                    classContent += `            try {\n`;
                    classContent += `                List<${modelName}> models = Files.lines(csvFile.toPath())\n`;
                    classContent += `                    .skip(1) // Skip header\n`;
                    classContent += `                    .map(line -> line.split(","))\n`;
                    classContent += `                    .map(values -> {\n`;
                    classContent += `                        ${modelName} model = new ${modelName}();\n`;
                    nonKeyColumnsForImport.forEach((col, i) => {
                        const setter = `set${toPascalCase(col.colName)}`;
                        const javaType = mapPostgresToJavaType(col.type);
                        let parseLogic = `values[${i}]`;
                        if (javaType === 'Long') parseLogic = `Long.parseLong(values[${i}])`;
                        else if (javaType === 'Integer') parseLogic = `Integer.parseInt(values[${i}])`;
                        else if (javaType === 'Boolean') parseLogic = `Boolean.parseBoolean(values[${i}])`;
                        else if (javaType === 'java.time.Instant') parseLogic = `Instant.parse(values[${i}])`;
                        
                        classContent += `                        if (values.length > ${i} && !values[${i}].isEmpty()) model.${setter}(${parseLogic});\n`;
                    });
                    classContent += `                        return model;\n`;
                    classContent += `                    })\n`;
                    classContent += `                    .collect(Collectors.toList());\n`;
                    classContent += `\n`;
                    classContent += `                return ${repoVar}.batchInsert(models).toCompletableFuture().join();\n`;
                    classContent += `            } catch (IOException e) {\n`;
                    classContent += `                throw new RuntimeException(e);\n`;
                    classContent += `            }\n`;
                    classContent += `        });\n`;
                    classContent += `    }\n`;

                    classContent += `}\n`;
                    javaString += classContent + '\n';
                });

                return javaString;
            }
        });
    </script>
</body>
</html>